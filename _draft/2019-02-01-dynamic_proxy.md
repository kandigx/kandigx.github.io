---
title: "动态代理"
permalink: /dynamic_proxy/
date: 2019-02-01
tags: [dynamic proxy, java, design pattern]

excerpt: "java, web, design pattern, dynamic proxy"
---
# 动态代理

## 代理模式

定义：为其他对象提供一种代理以控制对这个对象的访问。

### 结构

* Proxy: 代理对象。通常具有如下功能
实现与具体的目标对象一样的接口，这样就可以使用代理来代替具体的目标对象。保存一个指向具体目标对象的引用，可以在需要的时候调用具体的目标对象。

* Subject：目标接口，定义代理和具体的目标对象的接口，这样就可以在任何使用具体目标对象的地方使用代理对象。

* RealSuject：具体的目标对象，真正实现目标接口要求的功能。

### 代理分类

1. **虚代理**：根据需要来创建开销很大的对象，该对象只有在需要的时候才会被真正创建。

2. **保护代理**：控制对原始对象的访问，如果有需要，可以给不同的用户提供不同的访问权限，以控制他们对原始对象的访问

3. 远程代理：用来在不同的地址空间上代表同一个对象，这个不同的地址空间可以是在本机，也可以在其他机器上。Java中最经典的就是RMI技术。

4. 智能指引：在访问对象时执行一些附加操作，比如，对指向实际对象的引用计数、第一次引用一个持久对象时，将它装入内存等。

5. copy_on_write 代理：在客户端操作的时候，只有对象确实改变了，才会真的拷贝（或克隆）一个目标对象，算是虚代理的一个分支。

6. Cache 代理

7. 防火墙代理

8. 同步代理

### 代理模式的本质

**控制对象访问**

从实现上来看，代理模式主要是使用对象的组合和委托

也可以采用对象继承的方式来实现代理。

### 应用场景

* 需要为一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理

* 需要按照需求创建开销很大的对象的时候，可以使用虚代理

* 需要控制对原始对象的访问的时候，可以使用保护代理

* 需要在访问对象执行一些附加操作的时候，可以使用智能指引代理

### 个人理解

代理类要实现和目标对象一样的接口，即其方法与目标对象一致，这样的话在外部看来就和目标对象一样。

~~代理类要持有一个实际的目标对象，这样才能够保证外接调用的时候，是返回实际对象的方法，或者是实际对象方法包装之后的方法。~~

如果代理类能完全通过接口来操作它所代理的目标对象，那么代理对象就不需要知道具体的目标对象。

但如果代理类必须要实例化它代理的目标对象，那么代理类就必须知道具体别代理的对象，如此一个具体目标类通常会有一个代理类。这种情况多出现在虚代理的实现里面。

代理模式，也就是对目标对象的引用，是通过代理对象来完成的。

## Java 中的代理

代理类需要实现接口：  `java.lang.reflect.InvocationHandler`

代理类中持有一个目标接口。

在代理类中创建生成代理类的方法，方法中调用`java.lang.reflect.Proxy.newProxyInstance()`来产生代理对象，其中传入要代理的目标对象

在代理类中，实现的 `invoke()` 方法中调用 `method.invoke(subject, args)`方法来进行对目标接口方法的调用。




#### 静态代理

自己以 Proxy、Subject、RealSubject 等结构方式实现的代理模式成为静态代理。

存在较大的缺点，即如果Subject接口发生变化，那么代理类和具体的目标实现都要变化。

### 动态代理

使用 Java 内建的对代理模式支持的功能，来实现的代理成为动态代理。

区别：

    静态代理实现的时候，在 Subject 接口上定义很多的方法，代理类中也要实现这些方法。

    动态代理实现的时候，动态代理类始终只有一个 invoke 方法。

Java 动态代理只能代理接口，基本的实现是依靠Java的反射机制和动态生成class的技术，来动态生成被代理的接口的实现对象

要实现类的代理，可以使用 cglib。